// Generated by CoffeeScript 1.4.0

/* EXTEND JAVASCRIPT BASE OBJECT FOR MIXIN SUPPORT
*/


(function() {
  var A, Background, BaseObject, Bookkeeping, CANVAS_HEIGHT, CANVAS_WIDTH, Camera, Collision, Constructable, D, DOWN, Destructable, ENTER, HUD, LEFT, Label, LoadedImage, Loader, MenuNamu, Miekkailija, Movable, Namu, ONE, PhysicalObject, Player, Position, R, RIGHT, Renderable, Renderer, S, SNAKE_SIZE, SPACE, Score, Size, Snake, SnakeHead, TWO, TailBit, Ticker, UP, Vector, W, Wall, X, Y, Yaoi, clearActions, controlActions, controlDownEvents, controlUpEvents, game, gameLoader, prepareCanvas, processControls,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Object.prototype.extend = function(mixin) {
    var key, value, _base, _base1, _ref, _ref1, _ref2, _ref3;
    _ref = mixin.prototype;
    for (key in _ref) {
      value = _ref[key];
      if (key !== 'mixins') {
        this.prototype[key] = value;
      }
    }
    if ((_ref1 = (_base = this.prototype).mixins) == null) {
      _base.mixins = [];
    }
    if ((_ref2 = (_base1 = mixin.prototype).mixins) == null) {
      _base1.mixins = [];
    }
    this.prototype.mixins.push.apply(this.prototype.mixins, mixin.prototype.mixins);
    this.prototype.mixins.push(mixin);
    if ((_ref3 = mixin.descendants) == null) {
      mixin.descendants = [];
    }
    mixin.descendants.push(this);
    if (mixin.init != null) {
      return mixin.init(this);
    }
  };

  Object.prototype.include = function(mixin) {
    var key, value, _base, _base1, _ref, _ref1, _ref2,
      _this = this;
    _ref = mixin.prototype;
    for (key in _ref) {
      value = _ref[key];
      if (key !== 'mixins') {
        this.prototype[key] = value;
      }
    }
    if ((_ref1 = (_base = this.prototype).mixins) == null) {
      _base.mixins = [];
    }
    if ((_ref2 = (_base1 = mixin.prototype).mixins) == null) {
      _base1.mixins = [];
    }
    this.prototype.mixins.push.apply(this.prototype.mixins, mixin.prototype.mixins);
    this.prototype.mixins.push(mixin);
    return this.init = function(obj) {
      var M, _i, _len, _ref3, _ref4, _results;
      _ref3 = _this.prototype.mixins;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        M = _ref3[_i];
        if ((_ref4 = M.descendants) == null) {
          M.descendants = [];
        }
        if (M.descendants.indexOf(obj) === -1) {
          M.descendants.push(obj);
        }
        if (M.init != null) {
          _results.push(M.init(obj));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  };

  /* LOADER: keeps list of things that have to be ready before the game "runtime" can start
  */


  Loader = (function() {

    function Loader() {
      this.waitForThese = [this];
      this.__readyAndLoaded = false;
    }

    Loader.prototype.runWhenReady = function(callback) {
      this.launcher = callback;
      this.__readyAndLoaded = true;
      return this.testIfReady();
    };

    Loader.prototype.asyncWaitForLoading = function(object, callback) {
      var _this = this;
      this.waitForThese.push(object);
      object.__readyAndLoaded = false;
      return object.onload = function() {
        object.__readyAndLoaded = true;
        if (callback != null) {
          callback(object);
        }
        return _this.testIfReady();
      };
    };

    Loader.prototype.testIfReady = function() {
      var object, _i, _len, _ref;
      _ref = this.waitForThese;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (!object.__readyAndLoaded) {
          return false;
        }
      }
      return this.launcher();
    };

    return Loader;

  })();

  gameLoader = new Loader();

  LoadedImage = (function() {

    function LoadedImage(src) {
      this.loaded = __bind(this.loaded, this);
      this.img = new Image();
      gameLoader.asyncWaitForLoading(this.img, this.loaded);
      this.img.src = src;
    }

    LoadedImage.prototype.loaded = function() {
      this.size = new Vector(this.img.width, this.img.height);
      this.offset = new Vector(-this.img.width, -this.img.height);
      return this.offset.scale(0.5);
    };

    LoadedImage.prototype.toString = function() {
      return "LoadedImage " + this.img.src + " " + this.size + " " + this.offset;
    };

    return LoadedImage;

  })();

  /* KEY CONTROL HELPERS
  */


  /* Constant values
  */


  LEFT = 37;

  UP = 38;

  RIGHT = 39;

  DOWN = 40;

  SPACE = 32;

  ENTER = 13;

  A = 65;

  S = 83;

  D = 68;

  R = 82;

  W = 87;

  Y = 89;

  X = 88;

  ONE = 49;

  TWO = 50;

  controlActions = [];

  controlDownEvents = [];

  controlUpEvents = [];

  document.addEventListener("keydown", (function(eventInfo) {
    return controlDownEvents.push(eventInfo.which);
  }), false);

  document.addEventListener("keyup", (function(eventInfo) {
    return controlUpEvents.push(eventInfo.which);
  }), false);

  clearActions = function() {
    var _results;
    while (controlActions.pop()) {
      false;
    }
    while (controlDownEvents.pop()) {
      false;
    }
    _results = [];
    while (controlUpEvents.pop()) {
      _results.push(false);
    }
    return _results;
  };

  processControls = function(commands) {
    var action, e, index, _i, _len, _results;
    while ((e = controlDownEvents.pop()) != null) {
      action = commands[e];
      if ((action != null) && (controlActions.indexOf(action) === -1)) {
        controlActions.push(action);
      }
    }
    for (_i = 0, _len = controlActions.length; _i < _len; _i++) {
      action = controlActions[_i];
      action();
    }
    _results = [];
    while ((e = controlUpEvents.pop()) != null) {
      action = commands[e];
      if (action != null) {
        index = controlActions.indexOf(action);
        if (index !== -1) {
          _results.push(controlActions.splice(index, 1));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  /* PREPARE CANVAS
  */


  prepareCanvas = function(canvas_container) {
    var canvas, ctx;
    canvas = document.createElement("canvas");
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    ctx = canvas.getContext("2d");
    canvas_container.appendChild(canvas);
    return ctx;
  };

  /* RUNTIME HELPERS
  */


  /* re-define requestAnimFrame for cross-browser compability
  */


  window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  Ticker = (function() {

    function Ticker(tick) {
      this.run = __bind(this.run, this);

      this.updateFPScounter = __bind(this.updateFPScounter, this);
      this.tick_time = new Date().getTime();
      this.ticks = 0;
      this.fps = 0;
      this.last_fps_update_time = 0;
      this.tick = tick;
      this.running = false;
      this.todo = [];
    }

    Ticker.prototype.updateFPScounter = function() {
      var elapsed_time;
      elapsed_time = (new Date().getTime() - this.last_fps_update_time) / 1000;
      this.last_fps_update_time = this.tick_time;
      this.fps = Math.round(this.ticks / elapsed_time);
      return this.ticks = 0;
    };

    Ticker.prototype.render = function() {
      var r, type, _i, _len, _ref, _results;
      _ref = Renderer.descendants;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = type.prototype.instances;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            r = _ref1[_j];
            _results1.push(r.render(game.context));
          }
          return _results1;
        })());
      }
      return _results;
    };

    Ticker.prototype.stop = function() {
      return this.run = function() {
        return console.log("Stopped.");
      };
    };

    Ticker.prototype.launch = function() {
      if (!this.running) {
        this.running = true;
        return this.run();
      }
    };

    Ticker.prototype.doNextTick = function(callback) {
      return this.todo.push(callback);
    };

    Ticker.prototype.run = function() {
      var d;
      requestAnimFrame(this.run);
      this.delta_time = (new Date().getTime() - this.tick_time) / 1000;
      if (this.delta_time > 0.1) {
        this.delta_time = 0.1;
      }
      this.tick_time = new Date().getTime();
      this.ticks++;
      while (d = this.todo.pop()) {
        d();
      }
      this.tick();
      return this.render();
    };

    return Ticker;

  })();

  /* Mixins
  */


  Constructable = (function() {

    function Constructable() {}

    Constructable.prototype.supers = function() {
      var M, _i, _len, _ref, _results;
      _ref = this.mixins;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        M = _ref[_i];
        if (M.construct != null) {
          _results.push(M.construct(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Constructable;

  })();

  Destructable = (function() {

    function Destructable() {}

    Destructable.construct = function(instance) {
      return instance.__destroyed = false;
    };

    Destructable.destroyThese = [];

    Destructable.cleanTrash = function() {
      var M, deadObject, _results;
      _results = [];
      while (deadObject = this.destroyThese.pop()) {
        _results.push((function() {
          var _i, _len, _ref, _results1;
          _ref = deadObject.mixins;
          _results1 = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            M = _ref[_i];
            if (M.destruct != null) {
              _results1.push(M.destruct(deadObject));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Destructable.prototype.destroy = function() {
      this.__destroyed = true;
      return Destructable.destroyThese.push(this);
    };

    Destructable.annihilateEverything = function() {
      var i, type, _i, _j, _len, _len1, _ref, _ref1;
      _ref = Destructable.descendants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        _ref1 = type.prototype.instances;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          i = _ref1[_j];
          i.destroy();
        }
      }
      Destructable.cleanTrash();
      return clearActions();
    };

    return Destructable;

  })();

  Bookkeeping = (function() {

    function Bookkeeping() {}

    Bookkeeping.base_typeid = 1000;

    Bookkeeping.init = function(type) {
      type.prototype.created = [];
      type.prototype.instances = [];
      type.prototype.ids = {
        typeid: this.base_typeid,
        base_instanceid: this.base_typeid + 1
      };
      return this.base_typeid += 1000;
    };

    Bookkeeping.bookCreated = function() {
      var bookType, instance, _i, _len, _ref, _results;
      _ref = this.descendants;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bookType = _ref[_i];
        _results.push((function() {
          var _results1;
          _results1 = [];
          while (instance = bookType.prototype.created.pop()) {
            bookType.prototype.instances.push(instance);
            _results1.push(instance.__new = false);
          }
          return _results1;
        })());
      }
      return _results;
    };

    Bookkeeping.construct = function(instance) {
      instance.created.push(instance);
      instance.__new = true;
      instance.id = instance.ids.base_instanceid;
      return instance.ids.base_instanceid++;
    };

    Bookkeeping.destruct = function(instance) {
      var index;
      if (instance.__new) {
        if ((index = instance.created.indexOf(instance)) > -1) {
          return instance.created.splice(index, 1);
        }
      } else {
        if ((index = instance.instances.indexOf(instance)) > -1) {
          return instance.instances.splice(index, 1);
        }
      }
    };

    return Bookkeeping;

  })();

  Position = (function() {

    function Position() {}

    Position.prototype.Position = function(x, y) {
      if (y != null) {
        return this.moveTo(new Vector(x, y));
      } else {
        return this.moveTo(x);
      }
    };

    Position.prototype.moveTo = function(position) {
      this.position = position;
      if (this.size != null) {
        return this.update_edges();
      }
    };

    return Position;

  })();

  Renderable = (function() {

    function Renderable() {}

    Renderable.construct = function(instance) {
      if (instance.image != null) {
        return instance.render_img = instance.image;
      }
    };

    Renderable.prototype.Renderable = function(img) {
      return this.render_img = img;
    };

    Renderable.prototype.render = function(ctx) {
      ctx.save();
      ctx.translate(this.position.x, this.position.y);
      ctx.drawImage(this.render_img.img, this.render_img.offset.x, this.render_img.offset.y);
      return ctx.restore();
    };

    return Renderable;

  })();

  Size = (function() {

    function Size() {}

    Size.prototype.Size = function(w, h) {
      if (h != null) {
        this.size = new Vector(w, h);
      } else {
        this.size = w;
      }
      this.edge = {
        left: null,
        right: null,
        top: null,
        bottom: null
      };
      return this.update_edges();
    };

    Size.prototype.update_edges = function() {
      var half_x, half_y;
      half_x = this.size.x / 2;
      half_y = this.size.y / 2;
      this.edge.left = this.position.x - half_x;
      this.edge.right = this.position.x + half_x;
      this.edge.top = this.position.y - half_y;
      return this.edge.bottom = this.position.y + half_y;
    };

    return Size;

  })();

  Collision = (function() {

    function Collision() {}

    Collision.init = function(type) {
      if (type.prototype.mixins.indexOf(Size) === -1) {
        throw "Objektilla on oltava koko!" + type.prototype.toString();
      }
    };

    Collision.prototype.bbox_collision = function(that) {
      if ((this.edge.right > that.edge.left) && (this.edge.left < that.edge.right)) {
        if ((this.edge.top < that.edge.bottom) && (this.edge.bottom > that.edge.top)) {
          return that;
        }
      }
      return false;
    };

    Collision.prototype.collidesAny = function(objects) {
      var obj, result, _i, _len;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (obj === this) {
          continue;
        }
        result = this.bbox_collision(obj);
        if (result) {
          return result;
        }
      }
      return false;
    };

    Collision.prototype.collidesAll = function(objects) {
      var colliders, obj, result, _i, _len;
      colliders = [];
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (obj === this) {
          continue;
        }
        result = this.bbox_collision(obj);
        if (result) {
          colliders.push(result);
        }
      }
      return colliders;
    };

    return Collision;

  })();

  Movable = (function() {

    function Movable() {}

    Movable.construct = function(instance) {
      instance.velocity = new Vector(0, 0);
      return instance.speed = 0;
    };

    Movable.prototype.move = function() {
      if (this.speed > 0) {
        this.position.increment(this.velocity.times(game.ticker.delta_time));
        if (this.update_edges != null) {
          return this.update_edges();
        }
      }
    };

    Movable.prototype.setVelocity = function(x, y) {
      if (y != null) {
        this.velocity = new Vector(x, y);
      } else {
        this.velocity = x;
      }
      return this.speed = this.velocity.length();
    };

    Movable.prototype.accelerate = function(x, y) {
      this.velocity.increment(new Vector(x, y));
      return this.speed = this.velocity.length();
    };

    Movable.move = function() {
      var mover, movingType, _i, _len, _ref, _results;
      _ref = this.descendants;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        movingType = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = movingType.prototype.instances;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            mover = _ref1[_j];
            _results1.push(mover.move());
          }
          return _results1;
        })());
      }
      return _results;
    };

    return Movable;

  })();

  /* Let's collect 'em together.
  */


  BaseObject = (function() {

    function BaseObject() {}

    BaseObject.include(Constructable);

    BaseObject.include(Destructable);

    BaseObject.include(Bookkeeping);

    return BaseObject;

  })();

  PhysicalObject = (function() {

    function PhysicalObject() {}

    PhysicalObject.include(BaseObject);

    PhysicalObject.include(Renderable);

    PhysicalObject.include(Position);

    PhysicalObject.include(Size);

    PhysicalObject.include(Collision);

    return PhysicalObject;

  })();

  Renderer = (function() {

    function Renderer() {}

    Renderer.include(Constructable);

    Renderer.include(Destructable);

    Renderer.include(Bookkeeping);

    return Renderer;

  })();

  Vector = (function() {

    function Vector(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }

    /* WITH SIDE-EFFECTS
    */


    Vector.prototype.increment = function(that) {
      this.x = this.x + that.x;
      this.y = this.y + that.y;
      return this;
    };

    Vector.prototype.decrement = function(that) {
      this.x = this.x - that.x;
      this.y = this.y - that.y;
      return this;
    };

    Vector.prototype.scale = function(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    };

    /* WITHOUT SIDE-EFFECTS
    */


    Vector.prototype.plus = function(that) {
      return new Vector(this.x + that.x, this.y + that.y);
    };

    Vector.prototype.minus = function(that) {
      return new Vector(this.x - that.x, this.y - that.y);
    };

    Vector.prototype.per = function(scalar) {
      return new Vector(this.x / scalar, this.y / scalar);
    };

    Vector.prototype.times = function(scalar) {
      return new Vector(this.x * scalar, this.y * scalar);
    };

    Vector.prototype.clone = function() {
      return new Vector(this.x, this.y);
    };

    Vector.prototype.length = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Vector.prototype.floor = function() {
      return new Vector(Math.floor(this.x), Math.floor(this.y));
    };

    Vector.prototype.unit = function() {
      return this.per(this.length());
    };

    Vector.prototype.toString = function() {
      return "x: " + this.x + " y: " + this.y;
    };

    Vector.prototype.equals = function(that) {
      return this.x === that.x && this.y === that.y;
    };

    return Vector;

  })();

  Background = (function() {

    Background.extend(PhysicalObject);

    Background.image = new LoadedImage("img/terrain2.png");

    function Background() {
      this.supers();
      this.Renderable(Background.image);
      this.Position(new Vector(0, 0));
      this.Size(new Vector(CANVAS_WIDTH, CANVAS_HEIGHT));
    }

    Background.prototype.toString = function() {
      return "Background";
    };

    return Background;

  })();

  /* Camera: a movable viewport which points to the centre of the place that is supposed to be "on-screen"
  */


  Camera = (function() {

    Camera.extend(Renderer);

    Camera.extend(Position);

    Camera.extend(Size);

    Camera.extend(Collision);

    function Camera() {
      this.supers();
      this.Position(new Vector(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2));
      this.Size(new Vector(CANVAS_WIDTH, CANVAS_HEIGHT));
    }

    Camera.prototype.render = function(ctx) {
      var physicals, renderable, _i, _j, _len, _len1, _ref, _ref1;
      ctx.save();
      _ref = PhysicalObject.descendants;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        physicals = _ref[_i];
        _ref1 = this.collidesAll(physicals.prototype.instances);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          renderable = _ref1[_j];
          renderable.render(ctx);
        }
      }
      ctx.translate(-this.position.x, -this.position.y);
      return ctx.restore();
    };

    Camera.prototype.toString = function() {
      return "Camera";
    };

    return Camera;

  })();

  Namu = (function() {

    Namu.extend(PhysicalObject);

    Namu.extend(Movable);

    Namu.prototype.toString = function() {
      return "Namu";
    };

    Namu.prototype.image = new LoadedImage("img/namu.png");

    Namu.prototype.image2 = new LoadedImage("img/namu2.png");

    function Namu() {
      this.destroy = __bind(this.destroy, this);
      this.supers();
      this.Renderable(this.image);
      this.Position(new Vector(Math.random() * CANVAS_WIDTH, Math.random() * CANVAS_HEIGHT));
      this.Size(new Vector(16, 16));
      this.relocate();
      if (Math.random() > 0.7) {
        this.score = 3;
        this.render_img = this.image2;
      } else {
        this.score = 1;
      }
      this.eaten = false;
    }

    Namu.prototype.relocate = function() {
      var collider, type, _i, _len, _ref, _results;
      _ref = [Wall, SnakeHead, TailBit, Namu];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        collider = this.collidesAny(type.prototype.instances) || this.collidesAny(type.prototype.created);
        if (collider) {
          this.Position(new Vector(Math.random() * CANVAS_WIDTH, Math.random() * CANVAS_HEIGHT));
          _results.push(this.relocate());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Namu.prototype.getsEaten = function(eater) {
      if (!this.eaten) {
        this.eaten = true;
        this.setVelocity(eater.head.position.minus(this.position).times(10));
        new Namu();
        window.setTimeout(this.destroy, 100);
        return true;
      }
      return false;
    };

    Namu.prototype.destroy = function() {
      return Destructable.prototype.destroy.call(this);
    };

    Namu.prototype.move = function() {
      Movable.prototype.move.call(this);
      return this.setVelocity(this.velocity.scale(0.9));
    };

    Namu.destroyAll = function() {
      var n, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = Namu.prototype.instances;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.destroy();
      }
      _ref1 = Namu.prototype.created;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        n = _ref1[_j];
        _results.push(n.destroy());
      }
      return _results;
    };

    return Namu;

  })();

  MenuNamu = (function() {

    MenuNamu.extend(Namu);

    MenuNamu.prototype.toString = function() {
      return "MenuNamu";
    };

    function MenuNamu(callback) {
      var label;
      this.supers();
      this.Renderable(this.image);
      this.Position(new Vector(Math.random() * CANVAS_WIDTH * 0.8 + CANVAS_WIDTH * 0.1, Math.random() * CANVAS_HEIGHT * 0.35 + (CANVAS_HEIGHT * 0.4)));
      this.Size(new Vector(16, 16));
      this.relocate();
      this.callback = callback;
      label = new Label(this.callback.title, this.position.minus(new Vector(0, 13)));
      game.hud.add(label);
    }

    MenuNamu.prototype.getsEaten = function() {
      return this.callback();
    };

    MenuNamu.prototype.relocate = function() {
      var collider, type, _i, _len, _ref, _results;
      _ref = [Wall, SnakeHead, TailBit, Namu];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        collider = this.collidesAny(type.prototype.instances) || this.collidesAny(type.prototype.created);
        if (collider) {
          this.Position(new Vector(Math.random() * CANVAS_WIDTH * 0.8 + CANVAS_WIDTH * 0.1, Math.random() * CANVAS_HEIGHT * 0.6 + (CANVAS_HEIGHT * 0.3)));
          _results.push(this.relocate());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return MenuNamu;

  })();

  Snake = (function() {

    Snake.extend(BaseObject);

    Snake.prototype.toString = function() {
      return "Snake";
    };

    Snake.prototype.image_red = new LoadedImage("img/v_coll.png");

    /* Static methods
    */


    Snake.test_collisions = function() {
      var snake, _i, _len, _ref, _results;
      _ref = this.prototype.instances;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        snake = _ref[_i];
        _results.push(snake.collides());
      }
      return _results;
    };

    /* Instance methods
    */


    function Snake(player, pos) {
      this.disposeBody = __bind(this.disposeBody, this);

      var bit, _i, _len, _ref;
      this.supers();
      this.player = player;
      this.head = new SnakeHead(this, pos);
      this.tailBits = [];
      this.tailEnd = null;
      this.grow(40);
      _ref = this.tailBits;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bit = _ref[_i];
        bit.Renderable(bit.image2);
      }
      this.dead = false;
    }

    Snake.prototype.maxSpeed = 150;

    Snake.prototype.collides = function() {
      var bit, bits, namu, s, wall, _i, _j, _len, _len1, _ref;
      namu = this.head.collidesAny(Namu.prototype.instances);
      if (namu) {
        this.eat(namu);
      }
      wall = this.head.collidesAny(Wall.prototype.instances);
      if (wall) {
        this.head.Renderable(this.image_red);
        this.die();
      }
      _ref = Snake.prototype.instances;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (s !== this) {
          bits = this.head.collidesAll(s.tailBits);
          for (_j = 0, _len1 = bits.length; _j < _len1; _j++) {
            bit = bits[_j];
            bit.Renderable(this.image_red);
            this.head.Renderable(this.image_red);
            this.die();
          }
        }
      }
      bit = this.tailEnd;
      while (bit = bit.forward) {
        if (bit.total_pixels_moved > this.head.total_pixels_moved - 33) {
          break;
        }
        if (this.head.bbox_collision(bit)) {
          bit.Renderable(this.image_red);
          this.head.Renderable(this.image_red);
          this.die(bit);
        }
      }
      return false;
    };

    Snake.prototype.eat = function(namu) {
      var i, _i, _ref, _results;
      if (namu.getsEaten(this)) {
        this.grow(namu.score * 10);
        this.player.score.add(namu.score);
        _results = [];
        for (i = _i = 1, _ref = namu.score; _i <= _ref; i = _i += 1) {
          this.maxSpeed *= game.speedMultiplier;
          _results.push(this.head.velocity.scale(game.speedMultiplier));
        }
        return _results;
      }
    };

    Snake.prototype.grow = function(amount) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = amount; _i <= _ref; i = _i += 1) {
        _results.push(new TailBit(this));
      }
      return _results;
    };

    Snake.prototype.up = function() {
      if (this.head.velocity.y === 0 && this.head.up_karenssi.i <= 0) {
        this.head.setVelocity(0, -this.maxSpeed);
        return this.head.karenssi = this.head.down_karenssi;
      }
    };

    Snake.prototype.down = function() {
      if (this.head.velocity.y === 0 && this.head.down_karenssi.i <= 0) {
        this.head.setVelocity(0, this.maxSpeed);
        return this.head.karenssi = this.head.up_karenssi;
      }
    };

    Snake.prototype.left = function() {
      if (this.head.velocity.x === 0 && this.head.left_karenssi.i <= 0) {
        this.head.setVelocity(-this.maxSpeed, 0);
        return this.head.karenssi = this.head.right_karenssi;
      }
    };

    Snake.prototype.right = function() {
      if (this.head.velocity.x === 0 && this.head.right_karenssi.i <= 0) {
        this.head.setVelocity(this.maxSpeed, 0);
        return this.head.karenssi = this.head.left_karenssi;
      }
    };

    Snake.prototype.die = function(bit) {
      if (!this.dead) {
        if (bit != null) {
          bit.decompose_forward();
        }
        if (bit != null) {
          bit.decompose_backward();
        }
        this.dead = true;
        this.head.setVelocity(0, 0);
        this.collides = function() {
          return true;
        };
        this.tailEnd.decompose_forward();
        this.head.backward.decompose_backward();
        return this.player.died();
      }
    };

    Snake.prototype.disposeBody = function() {
      var t, _i, _len, _ref;
      _ref = this.tailBits;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        t.destroy();
      }
      this.head.destroy();
      return this.destroy();
    };

    Snake.prototype.delirium = function() {
      if (!this.__delirium) {
        this.__delirium = true;
        this.head.Renderable(this.image_red);
        this.tailEnd.follow = function() {
          if (!this.snake.dead && this.head.speed > 0) {
            this.snake.grow(1);
            this.snake.head.backward.Renderable(this.snake.image_red);
            return this.snake.player.score.add(Math.floor(game.ticker.delta_time * 97971));
          }
        };
        this.eat = function() {
          return false;
        };
        return this.die = function() {
          this.head.velocity.scale(-1);
          Movable.prototype.move.apply(this.head);
          return this.head.setVelocity(0, 0);
        };
      }
    };

    return Snake;

  })();

  SNAKE_SIZE = new Vector(16, 16);

  SnakeHead = (function() {

    SnakeHead.extend(PhysicalObject);

    SnakeHead.extend(Movable);

    SnakeHead.prototype.toString = function() {
      return "SnakeHead";
    };

    SnakeHead.prototype.image = new LoadedImage("img/v.png");

    function SnakeHead(snake, pos) {
      this.supers();
      this.Position(pos);
      this.Size(SNAKE_SIZE);
      this.relocate();
      this.snake = snake;
      this.total_pixels_moved = 0;
      this.up_karenssi = {
        i: 0
      };
      this.down_karenssi = {
        i: 0
      };
      this.left_karenssi = {
        i: 0
      };
      this.right_karenssi = {
        i: 0
      };
      this.karenssi = {
        i: 0
      };
    }

    SnakeHead.prototype.relocate = function() {
      var collider, type, _i, _len, _ref, _results;
      _ref = [Wall, SnakeHead, TailBit, Namu];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        collider = this.collidesAny(type.prototype.instances, true);
        if (collider) {
          this.Position(new Vector(Math.random() * CANVAS_WIDTH, Math.random() * CANVAS_HEIGHT));
          _results.push(this.relocate());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    SnakeHead.prototype.move = function() {
      Movable.prototype.move.apply(this);
      if (this.snake.collides()) {
        return;
      }
      if (this.speed === 0) {
        return;
      }
      this.snake.tailEnd.follow();
      this.pixels_moved = this.speed * game.ticker.delta_time;
      this.total_pixels_moved += this.pixels_moved;
      this.up_karenssi.i -= this.pixels_moved;
      this.down_karenssi.i -= this.pixels_moved;
      this.left_karenssi.i -= this.pixels_moved;
      this.right_karenssi.i -= this.pixels_moved;
      return this.karenssi.i = 16;
    };

    return SnakeHead;

  })();

  TailBit = (function() {

    TailBit.extend(PhysicalObject);

    TailBit.extend(Movable);

    TailBit.prototype.toString = function() {
      return "TailBit";
    };

    TailBit.prototype.image = new LoadedImage("img/v_munch.png");

    TailBit.prototype.image2 = new LoadedImage("img/v.png");

    function TailBit(snake) {
      this.decompose_backward = __bind(this.decompose_backward, this);

      this.decompose_forward = __bind(this.decompose_forward, this);
      this.supers();
      this.Position(snake.head.position.clone());
      this.Size(SNAKE_SIZE);
      this.head = snake.head;
      this.snake = snake;
      this.snake.tailBits.push(this);
      if (this.head.backward != null) {
        this.backward = this.head.backward;
        this.backward.forward = this;
      } else {
        this.backward = null;
        snake.tailEnd = this;
      }
      this.forward = this.head;
      this.head.backward = this;
      this.total_pixels_moved = this.head.total_pixels_moved;
    }

    TailBit.prototype.follow = function() {
      this.moveTo(this.head.position.clone());
      this.total_pixels_moved = this.head.total_pixels_moved;
      this.Renderable(this.image2);
      this.forward.backward = null;
      this.snake.tailEnd = this.forward;
      this.forward = this.head;
      this.backward = this.head.backward;
      this.head.backward = this;
      return this.backward.forward = this;
    };

    TailBit.prototype.decompose_forward = function() {
      if (this.speed === 0) {
        this.setVelocity(Math.random() * 50 - 25, Math.random() * 50 - 25);
      }
      if (this.forward.decompose_forward != null) {
        return window.setTimeout(this.forward.decompose_forward, 100 / this.snake.tailBits.length);
      }
    };

    TailBit.prototype.decompose_backward = function() {
      var _ref;
      if (this.speed === 0) {
        this.setVelocity(Math.random() * 50 - 25, Math.random() * 50 - 25);
      }
      if (((_ref = this.backward) != null ? _ref.decompose_backward : void 0) != null) {
        return window.setTimeout(this.backward.decompose_backward, 100 / this.snake.tailBits.length);
      }
    };

    TailBit.prototype.move = function() {
      Movable.prototype.move.call(this);
      return this.setVelocity(this.velocity.times(0.96));
    };

    return TailBit;

  })();

  Wall = (function() {

    Wall.extend(PhysicalObject);

    Wall.prototype.image = new LoadedImage("img/wall.png");

    Wall.prototype.image2 = new LoadedImage("img/wall2.png");

    function Wall(pos, size, type) {
      this.supers();
      this.Position(pos);
      this.Size(size);
      if (type === 2) {
        this.render_img = this.image2;
      }
      this.name = "Wall";
    }

    Wall.prototype.toString = function() {
      return "Wall";
    };

    Wall.prototype.render = function(ctx) {
      var x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      ctx.save();
      ctx.translate(this.edge.left, this.edge.top);
      for (y = _i = _ref = this.edge.top, _ref1 = this.edge.bottom - 1, _ref2 = this.render_img.size.y; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _i += _ref2) {
        ctx.save();
        for (x = _j = _ref3 = this.edge.left, _ref4 = this.edge.right - 1, _ref5 = this.render_img.size.x; _ref3 <= _ref4 ? _j <= _ref4 : _j >= _ref4; x = _j += _ref5) {
          ctx.drawImage(this.render_img.img, 0, 0);
          ctx.translate(this.render_img.size.x, 0);
        }
        ctx.restore();
        ctx.translate(0, this.render_img.size.y);
      }
      return ctx.restore();
    };

    return Wall;

  })();

  Player = (function() {

    Player.extend(BaseObject);

    Player.prototype.up = function() {
      var _ref;
      return (_ref = this.snake) != null ? _ref.up() : void 0;
    };

    Player.prototype.down = function() {
      var _ref;
      return (_ref = this.snake) != null ? _ref.down() : void 0;
    };

    Player.prototype.left = function() {
      var _ref;
      return (_ref = this.snake) != null ? _ref.left() : void 0;
    };

    Player.prototype.right = function() {
      var _ref;
      return (_ref = this.snake) != null ? _ref.right() : void 0;
    };

    Player.prototype.spawn = function() {
      return this.snake = new Snake(this, this.position.clone());
    };

    function Player(x, y, name) {
      this.spawn = __bind(this.spawn, this);

      this.right = __bind(this.right, this);

      this.left = __bind(this.left, this);

      this.down = __bind(this.down, this);

      this.up = __bind(this.up, this);
      this.position = new Vector(x, y);
      this.name = name;
      this.score = new Score(this);
      this.dead_snake = null;
    }

    Player.prototype.died = function() {
      this.dead_snake = this.snake;
      this.snake = null;
      setTimeout(this.spawn, 2100);
      setTimeout(this.dead_snake.disposeBody, 1700);
      return this.score.reset();
    };

    return Player;

  })();

  Score = (function() {

    Score.extend(BaseObject);

    function Score(player) {
      this.i = 0;
      this.player = player;
    }

    Score.prototype.add = function(n) {
      this.i += n;
      if (this.i >= game.winningScore) {
        return game.declareWinner(this.player);
      }
    };

    Score.prototype.reset = function() {
      return this.i = 0;
    };

    Score.prototype.toString = function() {
      return this.i;
    };

    return Score;

  })();

  HUD = (function() {

    HUD.extend(Renderer);

    function HUD() {
      this.supers();
      this.labels = [];
    }

    HUD.prototype.render = function(ctx) {
      var l, _i, _len, _ref, _results;
      _ref = this.labels;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        _results.push(l.render(ctx));
      }
      return _results;
    };

    HUD.prototype.add = function(label) {
      return this.labels.push(label);
    };

    return HUD;

  })();

  Label = (function() {

    Label.extend(BaseObject);

    Label.extend(Renderable);

    Label.extend(Position);

    function Label(text, pos, font, align, colour, stroke) {
      if (font == null) {
        font = "bold 20px sans-serif";
      }
      if (align == null) {
        align = "center";
      }
      if (colour == null) {
        colour = "#FFFFFF";
      }
      if (stroke == null) {
        stroke = false;
      }
      this.supers;
      this.text = text;
      this.Position(pos);
      this.font = font;
      this.align = align;
      this.colour = colour;
      this.stroke = stroke;
    }

    Label.prototype.render = function(ctx) {
      ctx.font = this.font;
      ctx.textAlign = this.align;
      ctx.fillStyle = this.colour;
      ctx.fillText(this.text, this.position.x, this.position.y);
      if (this.stroke) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = this.stroke;
        return ctx.strokeText(this.text, this.position.x, this.position.y);
      }
    };

    return Label;

  })();

  Yaoi = (function() {

    Yaoi.extend(Renderer);

    Yaoi.prototype.toString = function() {
      return "Yaoi";
    };

    Yaoi.prototype.olli = new LoadedImage("img/olli.png");

    Yaoi.prototype.mika = new LoadedImage("img/mika.png");

    function Yaoi() {
      this.supers();
      this.o = new Miekkailija(this.olli, new Vector(130, 220));
      this.m = new Miekkailija(this.mika, new Vector(270, 220));
      this.l = new Label("Mika ja Olli, harmoniset värähtelijät.", new Vector(200, 310), "bold 10px sans-serif");
      this.ll = new Label("YAOI_SHOW", new Vector(200, 130), "bold 20px sans-serif");
    }

    Yaoi.run = function() {
      if (this.prototype.instances.length > 0) {

      } else {
        this.running = new Yaoi();
      }
      return this.running.show = true;
    };

    Yaoi.prototype.render = function(ctx) {
      if (this.show) {
        this.l.render(ctx);
        this.ll.render(ctx);
        this.o.render(ctx);
        this.m.render(ctx);
        return this.show = false;
      }
    };

    return Yaoi;

  })();

  Miekkailija = (function() {

    Miekkailija.extend(BaseObject);

    Miekkailija.extend(Renderable);

    Miekkailija.extend(Position);

    Miekkailija.extend(Size);

    Miekkailija.extend(Collision);

    Miekkailija.extend(Movable);

    function Miekkailija(img, pos) {
      this.supers();
      this.Position(pos);
      this.Renderable(img);
      this.Size(this.render_img.size);
    }

    Miekkailija.prototype.move = function() {
      Movable.prototype.move.call(this);
      return this.accelerate((200 - this.position.x) * 0.5, 0);
    };

    return Miekkailija;

  })();

  CANVAS_WIDTH = 400;

  CANVAS_HEIGHT = 400;

  game = function() {
    /* Pre-initialization
    */

    var commands, container, initMenu, initOnePlayerGame, initTwoPlayerGame, tick;
    container = document.getElementById("game_area");
    game.context = prepareCanvas(container);
    commands = {};
    commands[UP] = function() {
      return game.playerA.up();
    };
    commands[DOWN] = function() {
      return game.playerA.down();
    };
    commands[LEFT] = function() {
      return game.playerA.left();
    };
    commands[RIGHT] = function() {
      return game.playerA.right();
    };
    commands[W] = function() {
      return game.playerB.up();
    };
    commands[S] = function() {
      return game.playerB.down();
    };
    commands[A] = function() {
      return game.playerB.left();
    };
    commands[D] = function() {
      return game.playerB.right();
    };
    commands[Y] = function() {
      return Yaoi.run();
    };
    commands[R] = function() {
      return initMenu();
    };
    /* Game initialization
    */

    initMenu = function() {
      var bg, l, wall1, wall2, wall3, wall4;
      Destructable.annihilateEverything();
      game.winningScore = 20;
      game.speedMultiplier = 1;
      game.playerA = new Player(200, 200, "Jäbä");
      game.cam = new Camera();
      game.hud = new HUD();
      bg = new Background();
      wall1 = new Wall(new Vector(200, 8), new Vector(400, 16), 1);
      wall2 = new Wall(new Vector(200, 392), new Vector(400, 16), 1);
      wall3 = new Wall(new Vector(8, 200), new Vector(16, 400), 1);
      wall4 = new Wall(new Vector(392, 200), new Vector(16, 400), 1);
      game.playerA.spawn();
      Bookkeeping.bookCreated();
      new MenuNamu(initTwoPlayerGame);
      new MenuNamu(initOnePlayerGame);
      l = new Label("Mato", new Vector(50, 50), "bold 20px sans-serif");
      game.hud.add(l);
      l = new Label("matalan", new Vector(100, 70), "bold 30px sans-serif");
      game.hud.add(l);
      l = new Label("touhukas", new Vector(150, 100), "bold 50px sans-serif");
      game.hud.add(l);
      l = new Label("maailma!", new Vector(405, 420), "bold 170px sans-serif");
      game.hud.add(l);
      l = new Label("'R' resettaa pelin.", new Vector(100, 111), "bold 10px sans-serif");
      game.hud.add(l);
      l = new Label("© Pyry Kontio / @GolDDranks", new Vector(380, 27), "bold 10px sans-serif", "right");
      game.hud.add(l);
      Bookkeeping.bookCreated();
      return game.ticker.launch();
    };
    initTwoPlayerGame = function() {
      var bg, wall1, wall2, wall3, wall4;
      Destructable.annihilateEverything();
      game.won = false;
      game.winningScore = 20;
      game.speedMultiplier = 1;
      game.playerA = new Player(200, 50, "Ylämato");
      game.playerB = new Player(200, 350, "Alamato");
      game.cam = new Camera();
      game.hud = new HUD();
      game.hud.add(new Label(game.playerA.score, new Vector(20, 13), "bold 12px sans-serif", "left"));
      game.hud.add(new Label(game.playerB.score, new Vector(20, 396), "bold 12px sans-serif", "left"));
      bg = new Background();
      wall1 = new Wall(new Vector(200, 8), new Vector(400, 16), 1);
      wall2 = new Wall(new Vector(200, 392), new Vector(400, 16), 1);
      wall3 = new Wall(new Vector(8, 200), new Vector(16, 400), 1);
      wall4 = new Wall(new Vector(392, 200), new Vector(16, 400), 1);
      Bookkeeping.bookCreated();
      game.playerA.spawn();
      game.playerB.spawn();
      Bookkeeping.bookCreated();
      new Namu();
      new Namu();
      new Namu();
      return game.ticker.launch();
    };
    initOnePlayerGame = function() {
      var bg, wall1, wall2, wall3, wall4;
      Destructable.annihilateEverything();
      game.won = false;
      game.winningScore = 20;
      game.speedMultiplier = 1.05;
      game.playerA = new Player(200, 200, "Jäbä");
      game.cam = new Camera();
      game.hud = new HUD();
      game.hud.add(new Label(game.playerA.score, new Vector(20, 13), "bold 12px sans-serif", "left"));
      bg = new Background();
      wall1 = new Wall(new Vector(200, 8), new Vector(400, 16), 1);
      wall2 = new Wall(new Vector(200, 392), new Vector(400, 16), 1);
      wall3 = new Wall(new Vector(8, 200), new Vector(16, 400), 1);
      wall4 = new Wall(new Vector(392, 200), new Vector(16, 400), 1);
      Bookkeeping.bookCreated();
      game.playerA.spawn();
      Bookkeeping.bookCreated();
      new Namu();
      new Namu();
      return game.ticker.launch();
    };
    initOnePlayerGame.title = "一人で";
    initTwoPlayerGame.title = "一対一";
    /* Runtime logic
    */

    game.declareWinner = function(player) {
      var l;
      if (!game.won) {
        game.won = true;
        player.snake.delirium();
        Namu.destroyAll();
        l = new Label(player.name + " voitti!", new Vector(200, 180), "bold 40px sans-serif");
        game.hud.add(l);
        l = new Label("'R' resettaa pelin.", new Vector(130, 191), "bold 10px sans-serif");
        return game.hud.add(l);
      }
    };
    tick = function() {
      processControls(commands);
      Movable.move();
      Destructable.cleanTrash();
      return Bookkeeping.bookCreated();
    };
    /* Launch
    */

    game.ticker = new Ticker(tick);
    return gameLoader.runWhenReady(initMenu);
  };

  /* By this time, the DOM tree should have been loaded
  */


  game();

}).call(this);
